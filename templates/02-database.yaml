# templates/postgres-statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres
  namespace: {{ .Release.Namespace }}
  labels:
    app.kubernetes.io/name: postgres
    app.kubernetes.io/instance: {{ .Release.Names }}
    app.kubernetes.io/version: "15"
    app.kubernetes.io/component: database
spec:
  serviceName: "service-postgres"
  replicas: 1
  selector:
    matchLabels:
      app: postgres
      tier: database
  template:
    metadata:
      labels:
        app: postgres
        tier: database
        app.kubernetes.io/name: postgres
        app.kubernetes.io/instance: {{ .Release.Names }}
        app.kubernetes.io/version: "15"
        app.kubernetes.io/component: database
        monitoring: "true"
        logging: "true"
    spec:
      containers:
      # --- MAIN CONTAINER ---
      - name: postgres
        image: postgres:15-alpine
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_PASSWORD
        - name: POSTGRES_DB
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: DATABASE_NAME
        volumeMounts:
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
      
      # --- SIDECAR CONTAINER ---
      - name: exporter
        image: prometheuscommunity/postgres-exporter:v0.18.1
        ports:
        - name: metrics-port # Имя порта внутри контейнера
          containerPort: 9187
        env:
# 1. Сначала извлекаем пароль из Секрета в переменную
        - name: SECRET_PASSWORD 
          valueFrom:
            secretKeyRef:
              name: postgres-secret
              key: POSTGRES_PASSWORD # Твой ключ в секрете
        # 2. Теперь используем эту переменную. 
        # ВАЖНО: Она должна идти ПОСЛЕ объявления SECRET_PASSWORD
        - name: DATA_SOURCE_NAME
          value: "postgresql://postgres:$(SECRET_PASSWORD)@127.0.0.1:5432/guestbook?sslmode=disable"

  volumeClaimTemplates:
  - metadata:
      name: postgres-data
    spec:
      storageClassName: local-storage
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
---
# templates/postgres-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: service-postgres
  namespace: {{ .Release.Namespace }}
  labels:
    app: svc-postgres # Лейбл для монитора
    tier: database
    app.kubernetes.io/name: postgres
    app.kubernetes.io/component: database
spec:
  selector:
    app: postgres
    tier: database
  ports:
    - name: postgres
      port: 5432
      targetPort: 5432
    - name: metrics
      port: 9187
      targetPort: 9187

---
# templates/postgres-monitor.yaml
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: postgres-monitor
  namespace: {{ .Release.Namespace }}       # <--- ОБЯЗАТЕЛЬНО раскомментируй
  labels:
    release: prometheus-stack  # ВАЖНО: Этот лейбл должен совпадать с именем релиза Хелма (prometheus-stack)
    app.kubernetes.io/name: postgres
    app.kubernetes.io/component: monitoring
spec:
  selector:
    matchLabels:
      app: svc-postgres    # Лейбл твоего Service
  namespaceSelector:       # Явно указываем, где искать сервис
    matchNames:
      - {{ .Release.Namespace }}
  endpoints:
  - port: metrics
    interval: 15s
    # Иногда экспортер требует указать путь, но по умолчанию это /metrics, так что ок.

---
# templates/storage-class.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: local-storage # ← имя "local-storage"
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer
reclaimPolicy: Retain # <--- ВОТ ОНО: данные не удалятся, если удалить PVC

---
# templates/pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: postgres-pv-local
  labels:
    type: local
    app: postgres
spec:
  storageClassName: local-storage # ← то же самое имя "local-storage"
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  hostPath:
    path: "/data/postgres" # Путь ВНУТРИ ноды Minikube (надо сначала сделать minikube mount)
    # Или, если драйвер Docker, это путь внутри контейнера minikube